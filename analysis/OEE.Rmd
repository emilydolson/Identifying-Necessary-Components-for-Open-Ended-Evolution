---
title: "Exploring open-ended evolution in NK Landscapes and Avida"
author: "Emily Dolson"
output: 
  html_document:
    toc: true
    toc_float: true

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#knitr::opts_chunk$set(cache = TRUE)
knitr::opts_chunk$set(message = FALSE)
```

```{r}
# Do set up and collect data
library(ggplot2)
library(dplyr)
library(tidyr)

# flat-violin geom will be needed for raincloud plots
source("geom_flat_violin.R")

# Set up theme for all plots
theme_set(theme_classic())
theme_update(axis.title = element_text(size=18), axis.text = element_text(size=12), legend.text = element_text(size=14), legend.title = element_text(size=14), legend.position = "bottom", strip.text = element_text(size=18))

nk_data <- read.csv("../data/nk_data.csv")
avida_data <- read.csv("../data/avida_data.csv")

```

# Avida analysis


```{r}
empty <- avida_data %>% filter(res == 100, environment %in% c("empty"), filter %in% c(500, 1000, 2000, 4000), fixedlength == 0)
empty_end <- avida_data %>% filter(res == 100, environment %in% c("empty"), filter %in% c(500, 1000, 2000, 4000), fixedlength == 0, generation == 200000)
env_comp <- avida_data %>% filter(res == 100, environment %in% c("empty", "l9"), filter == population_size, fixedlength == 0)
env_comp_end <- avida_data %>% filter(res == 100, environment %in% c("empty", "l9"), filter == population_size, fixedlength == 0, generation == 200000)
```

### Change

#### Filter length

```{r}
ggplot(data=empty) + stat_summary(aes(x=generation, y=change, color=as.factor(filter), fill=as.factor(filter)), fun.data="mean_cl_boot", geom="smooth") + facet_wrap(~population_size) + scale_x_continuous("Average Generation", labels = function(x) format(x, scientific = TRUE), expand=c(0.15, 0.15), limits=c(0,200000), breaks=c(0, 100000, 200000)) + scale_y_continuous("Change") + scale_color_discrete("Filter length (t)") + scale_fill_discrete("Filter length (t)")  + geom_hline(yintercept=c(1,1), linetype="dotted")
ggsave("../figs/avida_filter_change.png")
```

Okay, looks like the effect of the filter length is roughly as expected. Higher filter times more closely approximate the known ground truth (change=1). It's a little hard to tell how close they get from this view. Let's try a rain-cloud plot:

```{r}
ggplot(data=empty_end, aes(x=as.factor(filter), y=change, fill=as.factor(filter))) + geom_flat_violin(position = position_nudge(x = .2, y = 0)) + geom_point(aes(color = as.factor(filter)), position = position_jitter(width = .15), alpha = 0.8) + stat_summary(fun.data="mean_cl_boot", show.legend = FALSE) + facet_wrap(~population_size, scales = "free_x") + scale_x_discrete("Filter length (t)") + scale_y_continuous("Change") + scale_color_discrete("Filter length (t)")+ scale_fill_discrete("Filter length (t)") + geom_hline(yintercept=c(1,1), linetype="dotted") + theme(legend.position="None")
ggsave("../figs/avida_filter_change_end.png")
```

Okay, from this we tcan tell that using population size as t always produces reasonable results. Population size = t seems to get a little less noisey as population size increases, possibly due to the increased selection strength. The results of t=4000 for population size 2000 make it look like the actual ground truth is potentially a little below 1, which is reasonable (we don't necessarily expect change to occur in ever interval as evolution goes on). Even using half the population size as t appears to be generally reasonable. Once you go lower than that, though, things start to get pretty noisy. Using t greater than population size appears to clean things up a bit more, but there are diminishing returns. Based on this, we'd recommend population size or 2*population size as filter size.

#### Environment
```{r}

ggplot(data=env_comp) + stat_summary(aes(x=generation, y=change, color=as.factor(population_size), fill=as.factor(population_size)), fun.data="mean_cl_boot", geom="smooth") + facet_wrap(~environment, scales = "free_y") + scale_x_continuous("Average Generation", labels = function(x) format(x, scientific = TRUE), expand=c(0.1, 0.1), limits=c(0,200000), breaks=c(0, 100000, 200000)) + scale_y_continuous("Change") + scale_color_discrete("Population size") + scale_fill_discrete("Population size")
ggsave("../figs/avida_env_change.png")
```

```{r}
ggplot(data=env_comp_end, aes(x=as.factor(population_size), y=change, fill=as.factor(population_size))) + geom_flat_violin(position = position_nudge(x = .2, y = 0)) + geom_point(aes(color = as.factor(filter)), position = position_jitter(width = .15), alpha = 0.8) + stat_summary(fun.data="mean_cl_boot", show.legend = FALSE) + facet_wrap(~environment, scales = "free_x") + scale_x_discrete("Population size") + scale_y_continuous("Change") + geom_hline(yintercept=c(1,1), linetype="dotted")  + theme(legend.position="None")
ggsave("../figs/avida_env_change_end.png")
```

### Novelty
``` {r}
ggplot(data=empty) + stat_summary(aes(x=generation, y=novelty, color=as.factor(filter), fill=as.factor(filter)), fun.data="mean_cl_boot", geom="smooth") + facet_wrap(~population_size) + scale_x_continuous("Average Generation", labels = function(x) format(x, scientific = TRUE), expand=c(0.15, 0.15), limits=c(0,200000), breaks=c(0, 100000, 200000)) + scale_y_continuous("Novelty") + scale_color_discrete("Filter length (t)")+ scale_fill_discrete("Filter length (t)")  + geom_hline(yintercept=c(1,1), linetype="dotted")
ggsave("../figs/avida_filter_novelty.png")
```

```{r}
ggplot(data=empty_end, aes(x=as.factor(filter), y=novelty, fill=as.factor(filter))) + geom_flat_violin(position = position_nudge(x = .2, y = 0)) + geom_point(aes(color = as.factor(filter)), position = position_jitter(width = .15), alpha = 0.8) + stat_summary(fun.data="mean_cl_boot", show.legend = FALSE) + facet_wrap(~population_size, scales = "free_x") + scale_x_discrete("Filter length (t)") + scale_y_continuous("Novelty") + scale_color_discrete("Filter length (t)")+ scale_fill_discrete("Filter length (t)") + geom_hline(yintercept=c(1,1), linetype="dotted") + theme(legend.position="None") + theme(legend.position="None")
ggsave("../figs/avida_filter_novelty_end.png")
```


Novelty is almsot identical to change, consistent with fitness continuously increaseing (there shouldn't be opportunities for back-tracking)

#### Environment
```{r}

ggplot(data=env_comp) + stat_summary(aes(x=generation, y=novelty, color=as.factor(population_size), fill=as.factor(population_size)), fun.data="mean_cl_boot", geom="smooth") + facet_wrap(~environment, scales = "free_y") + scale_x_continuous("Average Generation", labels = function(x) format(x, scientific = TRUE), expand=c(0.1, 0.1), limits=c(0,200000), breaks=c(0, 100000, 200000)) + scale_y_continuous("Novelty") + scale_color_discrete("Population size") + scale_fill_discrete("Population size")
ggsave("../figs/avida_env_novelty.png")
```

```{r}
ggplot(data=env_comp_end, aes(x=as.factor(population_size), y=novelty, fill=as.factor(population_size))) + geom_flat_violin(position = position_nudge(x = .2, y = 0)) + geom_point(aes(color = as.factor(filter)), position = position_jitter(width = .15), alpha = 0.8) + stat_summary(fun.data="mean_cl_boot", show.legend = FALSE) + facet_wrap(~environment, scales = "free_x") + scale_x_discrete("Population size") + scale_y_continuous("Novelty") + geom_hline(yintercept=c(1,1), linetype="dotted")  + theme(legend.position="None")
ggsave("../figs/avida_env_novelty_end.png")
```

### Ecology
``` {r}
ggplot(data=empty) + stat_summary(aes(x=generation, y=ecology, color=as.factor(filter), fill=as.factor(filter)), fun.data="mean_cl_boot", geom="smooth") + facet_wrap(~population_size) + scale_x_continuous("Average Generation", labels = function(x) format(x, scientific = TRUE), expand=c(0.15, 0.15), limits=c(0,200000), breaks=c(0, 100000, 200000)) + scale_y_continuous("Ecology") + scale_color_discrete("Filter length (t)")+ scale_fill_discrete("Filter length (t)")  + geom_hline(yintercept=c(1,1), linetype="dotted")
ggsave("../figs/avida_filter_ecology.png")
```

Note sure if that curving pattern is real or what's up with it.

```{r}
ggplot(data=empty_end, aes(x=as.factor(filter), y=ecology, fill=as.factor(filter))) + geom_flat_violin(position = position_nudge(x = .2, y = 0)) + geom_point(aes(color = as.factor(filter)), position = position_jitter(width = .15), alpha = 0.8) + stat_summary(fun.data="mean_cl_boot", show.legend = FALSE) + facet_wrap(~population_size, scales = "free_x") + scale_x_discrete("Filter length (t)") + scale_y_continuous("Ecology") + scale_color_discrete("Filter length (t)")+ scale_fill_discrete("Filter length (t)") + geom_hline(yintercept=c(1,1), linetype="dotted")  + theme(legend.position="None")
ggsave("../figs/avida_filter_ecology_end.png")
```

Ecology seems a little more robust to using a low filter time (the tail on 500 in population size 2000 is much more reasonable), which makes sense, because things that are on their way out probably aren't very plentiful. The change in selection strength induced by increased population size doesn't seem to have a noticeable effect (filter time = population size prdocues equivalent ecology across population size). This also implies that the reason for low ecology is not a constraint induced by the population size (which is obvious in this case, because we know this is a single niche environment, but wouldn't be obvious if we didn't know as much about the system)

#### Environment
```{r}

ggplot(data=env_comp) + stat_summary(aes(x=generation, y=ecology, color=as.factor(population_size), fill=as.factor(population_size)), fun.data="mean_cl_boot", geom="smooth") + facet_wrap(~environment, scales = "free_y") + scale_x_continuous("Average Generation", labels = function(x) format(x, scientific = TRUE), expand=c(0.1, 0.1), limits=c(0,200000), breaks=c(0, 100000, 200000)) + scale_y_continuous("Ecology") + scale_color_discrete("Population size") + scale_fill_discrete("Population size")
ggsave("../figs/avida_env_ecology.png")
```

```{r}
ggplot(data=env_comp_end, aes(x=as.factor(population_size), y=ecology, fill=as.factor(population_size))) + geom_flat_violin(position = position_nudge(x = .2, y = 0)) + geom_point(aes(color = as.factor(filter)), position = position_jitter(width = .15), alpha = 0.8) + stat_summary(fun.data="mean_cl_boot", show.legend = FALSE) + facet_wrap(~environment, scales = "free_x") + scale_x_discrete("Population size") + scale_y_continuous("Ecology") + geom_hline(yintercept=c(1,1), linetype="dotted")  + theme(legend.position="None")
ggsave("../figs/avida_env_ecology_end.png")
```

### Complexity
``` {r}
ggplot(data=empty) + stat_summary(aes(x=generation, y=complexity, color=as.factor(filter), fill=as.factor(filter)), fun.data="mean_cl_boot", geom="smooth") + facet_wrap(~population_size) + scale_x_continuous("Average Generation", labels = function(x) format(x, scientific = TRUE), expand=c(0.15, 0.15), limits=c(0,200000), breaks=c(0, 100000, 200000)) + scale_y_continuous("Complexity") + scale_color_discrete("Filter length (t)")+ scale_fill_discrete("Filter length (t)")
ggsave("../figs/avida_filter_complexity.png")
```

Basically, things rapdily increase in complexity as they become better than the ancestor. Then they decrease as they find ways to optimize, and soon appoximately level out.

```{r}
ggplot(data=empty_end, aes(x=as.factor(filter), y=complexity, fill=as.factor(filter))) + geom_flat_violin(position = position_nudge(x = .2, y = 0)) + geom_point(aes(color = as.factor(filter)), position = position_jitter(width = .15), alpha = 0.8) + stat_summary(fun.data="mean_cl_boot", show.legend = FALSE) + facet_wrap(~population_size, scales = "free_x") + scale_x_discrete("Filter length (t)") + scale_y_continuous("Complexity") + scale_color_discrete("Filter length (t)")+ scale_fill_discrete("Filter length (t)")  + theme(legend.position="None")
ggsave("../figs/avida_filter_complexity_end.png")
```

By the end, complexity is pretty consistent in all of the populations, so there's not much going on here.

#### Environment
```{r}

ggplot(data=env_comp) + stat_summary(aes(x=generation, y=complexity, color=as.factor(population_size), fill=as.factor(population_size)), fun.data="mean_cl_boot", geom="smooth") + facet_wrap(~environment, scales = "free_y") + scale_x_continuous("Average Generation", labels = function(x) format(x, scientific = TRUE), expand=c(0.1, 0.1), limits=c(0,200000), breaks=c(0, 100000, 200000)) + scale_y_continuous("Complexity") + scale_color_discrete("Population size") + scale_fill_discrete("Population size")
ggsave("../figs/avida_env_complexity.png")
```

```{r}
ggplot(data=env_comp_end, aes(x=as.factor(population_size), y=complexity, fill=as.factor(population_size))) + geom_flat_violin(position = position_nudge(x = .2, y = 0)) + geom_point(aes(color = as.factor(filter)), position = position_jitter(width = .15), alpha = 0.8) + stat_summary(fun.data="mean_cl_boot", show.legend = FALSE) + facet_wrap(~environment, scales = "free_x") + scale_x_discrete("Population size") + scale_y_continuous("Complexity") + geom_hline(yintercept=c(1,1), linetype="dotted")  + theme(legend.position="None")
ggsave("../figs/avida_env_complexity_end.png")
```

# NK Landscape Analysis

First we need to clean up the NK dataframe a little


```{r}

#Order treatments correctly
nk_data <- transform(nk_data, treatment = case_when(
    K == 10 ~ "High K\n(10)", 
    N == 100 ~ "High N\n(100)", 
    MUT_RATE == .005 ~ "Low\nmutation\n(.005)", 
    MUT_RATE == .1 ~ "High\nmutation\n(.1)",
    POP_SIZE == 20 ~ "Small\npop\n(20)",
    POP_SIZE == 2000 ~ "Large\npop\n(2000)",
    CHANGE_TYPE == 1 ~ "Oscillating\nenvironment",
    CHANGE_RATE == 500 ~ "Changing\nenvironment",
    SELECTION == 1 ~ "Fitness\nsharing",
    TRUE   ~ "Base" 
))

nk_data$POP_SIZE <- as.factor(nk_data$POP_SIZE)
nk_data$MUT_RATE <- as.factor(nk_data$MUT_RATE)
nk_data$treatment <- factor(nk_data$treatment, levels=c("Base",  "Low\nmutation\n(.005)","High\nmutation\n(.1)","Small\npop\n(20)","Large\npop\n(2000)","Oscillating\nenvironment","High K\n(10)","High N\n(100)", "Changing\nenvironment", "Fitness\nsharing"))

nk_endpoints <- nk_data %>% filter(generation == 5000)
nk_filter_pop_size <- nk_data %>% filter(FILTER_LENGTH == POP_SIZE, treatment != "Changing\nenvironment")
nk_filter_pop_size_endpoints <- nk_filter_pop_size %>% filter(generation == 5000)

```

### Change

First lets take a look at change over time across conditions

```{r}
ggplot(data=nk_filter_pop_size) + stat_summary(fun.data = mean_cl_boot, aes(y=change, x=generation, color=treatment, fill=treatment), geom="smooth") + scale_x_continuous("Generation") + scale_y_continuous("Change")
```

Wow, that's too many lines. As expected, Base, Fitness Sharing, and Oscillating are the only ones really doing interesting stuff over time (the spike in large pop is just the change it detects when the filter time first passes). Let's make a plot with just them.

```{r}
ggplot(data=nk_filter_pop_size %>% filter(treatment %in% c("Base", "Fitness\nsharing", "Oscillating\nenvironment"))) + stat_summary(fun.data = mean_cl_boot, aes(y=change, x=generation, color=treatment, fill=treatment), geom="smooth") + scale_x_continuous("Generation") + scale_y_continuous("Change")  + scale_color_discrete("") + scale_fill_discrete("")
ggsave("../figs/change_changing_environments.png")
```

And let's take a look at the end points to summarize all the conditions

```{r}
ggplot(data=nk_filter_pop_size_endpoints, aes(x=treatment, y=change, fill=treatment)) + geom_flat_violin(position = position_nudge(x = .2, y = 0)) + geom_point(aes(color = treatment), position = position_jitter(height = .1, width = .15), alpha = 0.8) + stat_summary(fun.data="mean_cl_boot", show.legend = FALSE) + scale_y_continuous("Change")  + scale_x_discrete("") + theme(legend.position="None")
ggsave("../figs/changeboxplots.png")
```

### Novelty

```{r}
ggplot(data=nk_filter_pop_size) + stat_summary(fun.data = mean_cl_boot, aes(y=novelty, x=generation, color=treatment, fill=treatment), geom="smooth") + scale_x_continuous("Generation") + scale_y_continuous("Novelty") + scale_color_discrete("") + scale_fill_discrete("")
```

Again, too many lines, but we can see that there is a general downward trend amongst those that start high enough to trend downward.

Let's plot an informative subset of the conditions (changing mutation rates):

```{r}
ggplot(data=nk_filter_pop_size %>% filter(treatment %in% c("Base", "Low\nmutation\n(.005)", "High\nmutation\n(.1)"))) + stat_summary(fun.data = mean_cl_boot, aes(y=novelty, x=generation, color=treatment, fill=treatment), geom="smooth") + scale_x_continuous("Generation") + scale_y_continuous("Novelty") + scale_color_discrete("") + scale_fill_discrete("")
ggsave("../figs/novelty_mean_mut_rate.png")
```

And a summary of the endpoints of everything

```{r}
ggplot(data=nk_filter_pop_size_endpoints, aes(x=treatment, y=novelty, fill=treatment)) + geom_flat_violin(position = position_nudge(x = .2, y = 0)) + geom_point(aes(color = treatment), position = position_jitter(height = .1, width = .15), alpha = 0.8) + stat_summary(fun.data="mean_cl_boot", show.legend = FALSE) + scale_y_continuous("Novelty")  + scale_x_discrete("") + theme(legend.position="None")
ggsave("../figs/noveltyboxplots.png")

```

### Ecology

```{r}
ggplot(data=nk_filter_pop_size) + stat_summary(fun.data = mean_cl_boot, aes(y=ecology, x=generation, color=treatment, fill=treatment), geom="smooth") + scale_x_continuous("Generation") + scale_y_continuous("Ecology") + scale_color_discrete("") + scale_fill_discrete("")
```

Really, the main take-away here is that fitness sharing creates ecology and nothing else does. We probably don't need to include a graph of ecology over time in the paper.


The endpoints are informative, though:

```{r}
ggplot(data=nk_filter_pop_size_endpoints, aes(x=treatment, y=ecology, fill=treatment)) + geom_flat_violin(position = position_nudge(x = .2, y = 0)) + geom_point(aes(color = treatment), position = position_jitter(height = .1, width = .15), alpha = 0.8) + stat_summary(fun.data="mean_cl_boot", show.legend = FALSE) + scale_y_continuous("Ecology")  + scale_x_discrete("") + theme(legend.position="None")
ggsave("../figs/ecologyboxplots.png")
```

### Complexity

```{r}
ggplot(data=nk_filter_pop_size) + stat_summary(fun.data = mean_cl_boot, aes(y=complexity, x=generation, color=treatment, fill=treatment), geom="smooth") + scale_x_continuous("Generation") + scale_y_continuous("Complexity") + scale_color_discrete("") + scale_fill_discrete("")
```

Obviously high N can have higher complexity and it approaches the maximum more gradually. It's throwing off the scale, though, so let's make a graph without it.

```{r}
ggplot(data=nk_filter_pop_size %>% filter(treatment != "High N\n(100)")) + stat_summary(fun.data = mean_cl_boot, aes(y=complexity, x=generation, color=treatment, fill=treatment), geom="smooth") + scale_x_continuous("Generation") + scale_y_continuous("Complexity") + scale_color_discrete("") + scale_fill_discrete("")
```

Nothing super interesting about looking at this over time. As expected, the oscillating environment is periodically pushed away from maximum complexity. We can just graph the endpoints and get the interesting parts of the story which are that fitness sharing, small pop, and high mutation are generally lower.

```{r}
ggplot(data=nk_filter_pop_size_endpoints %>% filter(treatment != "High N\n(100)"), aes(x=treatment, y=complexity, fill=treatment)) + geom_flat_violin(position = position_nudge(x = .2, y = 0)) + geom_point(aes(color = treatment), position = position_jitter(height = .1, width = .15), alpha = 0.8) + stat_summary(fun.data="mean_cl_boot", show.legend = FALSE) + scale_y_continuous("Complexity")  + scale_x_discrete("") + theme(legend.position="None")
ggsave("../figs/complexityboxplots.png")
```

Oh, right, the re-implemented version of the NK Landscape incorporates fitness sharing into the fitness function itself (i.e. the one that is used for the complexity calculation). As a result, complexity in fitness sharing isn't actually decreased notably despite the fact that the population is presumably not sitting on an actual fitness peak in the NK Landscape. This is probably the correct way to measure it though, since fitness sharing does change the fitness landscape.